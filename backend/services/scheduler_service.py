# scheduler_service.py
from datetime import datetime, timedelta, timezone
import pytz

def _parse_hhmm(hhmm: str):
    hh, mm = hhmm.split(":")
    return int(hh), int(mm)

def schedule_subtasks(now_utc: datetime, tz_name: str, work_start_hhmm: str, work_end_hhmm: str,
                      buffer_min: int, subtasks):
    """
    Returns subtasks with aware UTC datetimes for planned_start_ts / planned_end_ts,
    never in the past relative to now_utc.

    UPDATED LOGIC:
    - Smart buffering: If a subtask is a "Break" step (generated by AI), or if the 
      IMMEDIATELY following subtask is a "Break" step, we set the buffer to 0. 
      This prevents the "Double Gap" issue where you have [Task] -> [Buffer] -> [Break].
    """
    # Ensure 'now_utc' is aware UTC
    if now_utc.tzinfo is None:
        now_utc = now_utc.replace(tzinfo=timezone.utc)
    else:
        now_utc = now_utc.astimezone(timezone.utc)

    tz = pytz.timezone(tz_name or "Asia/Kolkata")
    now_local = now_utc.astimezone(tz)

    wh, wm = _parse_hhmm(work_start_hhmm)
    eh, em = _parse_hhmm(work_end_hhmm)

    def local_day_start(d):
        return d.replace(hour=wh, minute=wm, second=0, microsecond=0)
    def local_day_end(d):
        return d.replace(hour=eh, minute=em, second=0, microsecond=0)

    # Start from max(now, work start), rounded up to next minute
    start_local = max(now_local, local_day_start(now_local))
    if start_local.second or start_local.microsecond:
        start_local = (start_local + timedelta(minutes=1)).replace(second=0, microsecond=0)

    if start_local > local_day_end(now_local):
        start_local = local_day_start(now_local + timedelta(days=1))

    scheduled = []
    cursor = start_local

    # Use enumerate so we can peek at the next task
    for i, st in enumerate(subtasks):
        est = timedelta(minutes=int(st["estimate_min"]))

        # Switch to next day if no room today
        if cursor + est > local_day_end(cursor):
            cursor = local_day_start(cursor + timedelta(days=1))

        # Final “no past” clamp for races
        if cursor < now_local:
            cursor = (now_local + timedelta(minutes=1)).replace(second=0, microsecond=0)

        start_dt_local = cursor
        end_dt_local = cursor + est
        
        # --- SMART BUFFER LOGIC START ---
        
        # Check if current task is a break
        title = st.get("title", "").strip().lower()
        is_current_break = title.startswith("break:")
        
        # Check if next task is a break (lookahead)
        is_next_break = False
        if i + 1 < len(subtasks):
            next_st = subtasks[i + 1]
            next_title = next_st.get("title", "").strip().lower()
            if next_title.startswith("break:"):
                is_next_break = True

        # Rule: No buffer if the current step is a break OR the next step is a break.
        # Otherwise, use the user's default preference.
        if is_current_break or is_next_break:
            actual_buffer = 0
        else:
            actual_buffer = buffer_min

        # --- SMART BUFFER LOGIC END ---

        cursor = end_dt_local + timedelta(minutes=actual_buffer)

        st["planned_start_ts"] = start_dt_local.astimezone(timezone.utc)
        st["planned_end_ts"]   = end_dt_local.astimezone(timezone.utc)
        scheduled.append(st)

    return scheduled